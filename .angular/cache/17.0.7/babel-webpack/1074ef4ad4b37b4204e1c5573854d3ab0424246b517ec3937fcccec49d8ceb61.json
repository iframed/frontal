{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, PLATFORM_ID, Component, Inject, Input, Output, HostBinding, NgModule } from '@angular/core';\nimport * as i2 from '@angular/common';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { getBsVer, LinkedList } from 'ngx-bootstrap/utils';\nfunction CarouselComponent_ng_container_1_li_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"li\", 7);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_ng_container_1_li_2_Template_li_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r8);\n      const i_r6 = restoredCtx.index;\n      const ctx_r7 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r7.selectSlide(i_r6));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const slide_r5 = ctx.$implicit;\n    i0.ɵɵclassProp(\"active\", slide_r5.active === true);\n  }\n}\nfunction CarouselComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"ol\", 5);\n    i0.ɵɵtemplate(2, CarouselComponent_ng_container_1_li_2_Template, 1, 2, \"li\", 6);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.indicatorsSlides());\n  }\n}\nfunction CarouselComponent_ng_container_2_button_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 9);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_ng_container_2_button_2_Template_button_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r13);\n      const i_r11 = restoredCtx.index;\n      const ctx_r12 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r12.selectSlide(i_r11));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const slide_r10 = ctx.$implicit;\n    const i_r11 = ctx.index;\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassProp(\"active\", slide_r10.active === true);\n    i0.ɵɵattribute(\"data-bs-target\", \"#carousel\" + ctx_r9.currentId)(\"data-bs-slide-to\", i_r11);\n  }\n}\nfunction CarouselComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 5);\n    i0.ɵɵtemplate(2, CarouselComponent_ng_container_2_button_2_Template, 1, 4, \"button\", 8);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r1.indicatorsSlides());\n  }\n}\nfunction CarouselComponent_a_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"a\", 10);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_a_5_Template_a_click_0_listener() {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r14 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r14.previousSlide());\n    });\n    i0.ɵɵelement(1, \"span\", 11);\n    i0.ɵɵelementStart(2, \"span\", 12);\n    i0.ɵɵtext(3, \"Previous\");\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"disabled\", ctx_r2.checkDisabledClass(\"prev\"));\n    i0.ɵɵattribute(\"data-bs-target\", \"#carousel\" + ctx_r2.currentId);\n  }\n}\nfunction CarouselComponent_a_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r17 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"a\", 13);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_a_6_Template_a_click_0_listener() {\n      i0.ɵɵrestoreView(_r17);\n      const ctx_r16 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r16.nextSlide());\n    });\n    i0.ɵɵelement(1, \"span\", 14);\n    i0.ɵɵelementStart(2, \"span\", 12);\n    i0.ɵɵtext(3, \"Next\");\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"disabled\", ctx_r3.checkDisabledClass(\"next\"));\n    i0.ɵɵattribute(\"data-bs-target\", \"#carousel\" + ctx_r3.currentId);\n  }\n}\nconst _c0 = a0 => ({\n  \"display\": a0\n});\nconst _c1 = [\"*\"];\nclass CarouselConfig {\n  constructor() {\n    /* Default interval of auto changing of slides */\n    this.interval = 5000;\n    /* Is loop of auto changing of slides can be paused */\n    this.noPause = false;\n    /* Is slides can wrap from the last to the first slide */\n    this.noWrap = false;\n    /* Show carousel-indicators */\n    this.showIndicators = true;\n    /* Slides can be paused on focus */\n    this.pauseOnFocus = false;\n    /* If `true` - carousel indicators indicate slides chunks works ONLY if singleSlideOffset = FALSE */\n    this.indicatorsByChunk = false;\n    /* If value more then 1 — carousel works in multilist mode */\n    this.itemsPerSlide = 1;\n    /* If `true` — carousel shifts by one element. By default carousel shifts by number\n      of visible elements (itemsPerSlide field) */\n    this.singleSlideOffset = false;\n  }\n  static #_ = this.ɵfac = function CarouselConfig_Factory(t) {\n    return new (t || CarouselConfig)();\n  };\n  static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CarouselConfig,\n    factory: CarouselConfig.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CarouselConfig, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\n/**\n * Returns the index of the last element in the array where predicate is true, and -1\n * otherwise.\n * @param array The source array to search in\n * @param predicate find calls predicate once for each element of the array, in descending\n * order, until it finds one where predicate returns true. If such an element is found,\n * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n */\nfunction findLastIndex(array, predicate) {\n  let l = array.length;\n  while (l--) {\n    if (predicate(array[l], l, array)) {\n      return l;\n    }\n  }\n  return -1;\n}\nfunction chunkByNumber(array, size) {\n  const out = [];\n  const n = Math.ceil(array.length / size);\n  let i = 0;\n  while (i < n) {\n    const chunk = array.splice(0, i === n - 1 && size < array.length ? array.length : size);\n    out.push(chunk);\n    i++;\n  }\n  return out;\n}\nfunction isNumber(value) {\n  return typeof value === 'number' || Object.prototype.toString.call(value) === '[object Number]';\n}\n\n/***\n * pause (not yet supported) (?string='hover') - event group name which pauses\n * the cycling of the carousel, if hover pauses on mouseenter and resumes on\n * mouseleave keyboard (not yet supported) (?boolean=true) - if false\n * carousel will not react to keyboard events\n * note: swiping not yet supported\n */\n/****\n * Problems:\n * 1) if we set an active slide via model changes, .active class remains on a\n * current slide.\n * 2) if we have only one slide, we shouldn't show prev/next nav buttons\n * 3) if first or last slide is active and noWrap is true, there should be\n * \"disabled\" class on the nav buttons.\n * 4) default interval should be equal 5000\n */\nvar Direction;\n(function (Direction) {\n  Direction[Direction[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  Direction[Direction[\"NEXT\"] = 1] = \"NEXT\";\n  Direction[Direction[\"PREV\"] = 2] = \"PREV\";\n})(Direction || (Direction = {}));\nlet _currentId = 1;\n/**\n * Base element to create carousel\n */\nclass CarouselComponent {\n  /** Index of currently displayed slide(started for 0) */\n  set activeSlide(index) {\n    if (this.multilist) {\n      return;\n    }\n    if (isNumber(index)) {\n      this.customActiveSlide = index;\n    }\n    if (this._slides.length && index !== this._currentActiveSlide) {\n      this._select(index);\n    }\n  }\n  get activeSlide() {\n    return this._currentActiveSlide || 0;\n  }\n  /**\n   * Delay of item cycling in milliseconds. If false, carousel won't cycle\n   * automatically.\n   */\n  get interval() {\n    return this._interval;\n  }\n  set interval(value) {\n    this._interval = value;\n    this.restartTimer();\n  }\n  get slides() {\n    return this._slides.toArray();\n  }\n  get isFirstSlideVisible() {\n    const indexes = this.getVisibleIndexes();\n    if (!indexes || indexes instanceof Array && !indexes.length) {\n      return false;\n    }\n    return indexes.includes(0);\n  }\n  get isLastSlideVisible() {\n    const indexes = this.getVisibleIndexes();\n    if (!indexes || indexes instanceof Array && !indexes.length) {\n      return false;\n    }\n    return indexes.includes(this._slides.length - 1);\n  }\n  get _bsVer() {\n    return getBsVer();\n  }\n  constructor(config, ngZone, platformId) {\n    this.ngZone = ngZone;\n    this.platformId = platformId;\n    /* If `true` — carousel will not cycle continuously and will have hard stops (prevent looping) */\n    this.noWrap = false;\n    /*  If `true` — will disable pausing on carousel mouse hover */\n    this.noPause = false;\n    /*  If `true` — carousel-indicators are visible  */\n    this.showIndicators = true;\n    /*  If `true` - autoplay will be stopped on focus */\n    this.pauseOnFocus = false;\n    /* If `true` - carousel indicators indicate slides chunks\n       works ONLY if singleSlideOffset = FALSE */\n    this.indicatorsByChunk = false;\n    /* If value more then 1 — carousel works in multilist mode */\n    this.itemsPerSlide = 1;\n    /* If `true` — carousel shifts by one element. By default carousel shifts by number\n       of visible elements (itemsPerSlide field) */\n    this.singleSlideOffset = false;\n    /** Turn on/off animation. Animation doesn't work for multilist carousel */\n    this.isAnimated = false;\n    /** Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property */\n    this.activeSlideChange = new EventEmitter(false);\n    /** Will be emitted when active slides has been changed in multilist mode */\n    this.slideRangeChange = new EventEmitter();\n    /* Index to start display slides from it */\n    this.startFromIndex = 0;\n    this._interval = 5000;\n    this._slides = new LinkedList();\n    this._currentVisibleSlidesIndex = 0;\n    this.isPlaying = false;\n    this.destroyed = false;\n    this.currentId = 0;\n    this.getActive = slide => slide.active;\n    this.makeSlidesConsistent = slides => {\n      slides.forEach((slide, index) => slide.item.order = index);\n    };\n    Object.assign(this, config);\n    this.currentId = _currentId++;\n  }\n  ngAfterViewInit() {\n    setTimeout(() => {\n      if (this.singleSlideOffset) {\n        this.indicatorsByChunk = false;\n      }\n      if (this.multilist) {\n        this._chunkedSlides = chunkByNumber(this.mapSlidesAndIndexes(), this.itemsPerSlide);\n        this.selectInitialSlides();\n      }\n      if (this.customActiveSlide && !this.multilist) {\n        this._select(this.customActiveSlide);\n      }\n    }, 0);\n  }\n  ngOnDestroy() {\n    this.destroyed = true;\n  }\n  /**\n   * Adds new slide. If this slide is first in collection - set it as active\n   * and starts auto changing\n   * @param slide\n   */\n  addSlide(slide) {\n    this._slides.add(slide);\n    if (this.multilist && this._slides.length <= this.itemsPerSlide) {\n      slide.active = true;\n    }\n    if (!this.multilist && this.isAnimated) {\n      slide.isAnimated = true;\n    }\n    if (!this.multilist && this._slides.length === 1) {\n      this._currentActiveSlide = undefined;\n      if (!this.customActiveSlide) {\n        this.activeSlide = 0;\n      }\n      this.play();\n    }\n    if (this.multilist && this._slides.length > this.itemsPerSlide) {\n      this.play();\n    }\n  }\n  /**\n   * Removes specified slide. If this slide is active - will roll to another\n   * slide\n   * @param slide\n   */\n  removeSlide(slide) {\n    const remIndex = this._slides.indexOf(slide);\n    if (this._currentActiveSlide === remIndex) {\n      // removing of active slide\n      let nextSlideIndex;\n      if (this._slides.length > 1) {\n        // if this slide last - will roll to first slide, if noWrap flag is\n        // FALSE or to previous, if noWrap is TRUE in case, if this slide in\n        // middle of collection, index of next slide is same to removed\n        nextSlideIndex = !this.isLast(remIndex) ? remIndex : this.noWrap ? remIndex - 1 : 0;\n      }\n      this._slides.remove(remIndex);\n      // prevents exception with changing some value after checking\n      setTimeout(() => {\n        this._select(nextSlideIndex);\n      }, 0);\n    } else {\n      this._slides.remove(remIndex);\n      const currentSlideIndex = this.getCurrentSlideIndex();\n      setTimeout(() => {\n        // after removing, need to actualize index of current active slide\n        this._currentActiveSlide = currentSlideIndex;\n        this.activeSlideChange.emit(this._currentActiveSlide);\n      }, 0);\n    }\n  }\n  nextSlideFromInterval(force = false) {\n    this.move(Direction.NEXT, force);\n  }\n  /**\n   * Rolling to next slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n  nextSlide(force = false) {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n    this.move(Direction.NEXT, force);\n  }\n  /**\n   * Rolling to previous slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n  previousSlide(force = false) {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n    this.move(Direction.PREV, force);\n  }\n  getFirstVisibleIndex() {\n    return this.slides.findIndex(this.getActive);\n  }\n  getLastVisibleIndex() {\n    return findLastIndex(this.slides, this.getActive);\n  }\n  move(direction, force = false) {\n    const firstVisibleIndex = this.getFirstVisibleIndex();\n    const lastVisibleIndex = this.getLastVisibleIndex();\n    if (this.noWrap) {\n      if (direction === Direction.NEXT && this.isLast(lastVisibleIndex) || direction === Direction.PREV && firstVisibleIndex === 0) {\n        return;\n      }\n    }\n    if (!this.multilist) {\n      this.activeSlide = this.findNextSlideIndex(direction, force) || 0;\n    } else {\n      this.moveMultilist(direction);\n    }\n  }\n  /**\n   * Swith slides by enter, space and arrows keys\n   * @internal\n   */\n  keydownPress(event) {\n    if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n      this.nextSlide();\n      event.preventDefault();\n      return;\n    }\n    if (event.keyCode === 37 || event.key === 'LeftArrow') {\n      this.previousSlide();\n      return;\n    }\n    if (event.keyCode === 39 || event.key === 'RightArrow') {\n      this.nextSlide();\n      return;\n    }\n  }\n  /**\n   * Play on mouse leave\n   * @internal\n   */\n  onMouseLeave() {\n    if (!this.pauseOnFocus) {\n      this.play();\n    }\n  }\n  /**\n   * Play on mouse up\n   * @internal\n   */\n  onMouseUp() {\n    if (!this.pauseOnFocus) {\n      this.play();\n    }\n  }\n  /**\n   * When slides on focus autoplay is stopped(optional)\n   * @internal\n   */\n  pauseFocusIn() {\n    if (this.pauseOnFocus) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n  /**\n   * When slides out of focus autoplay is started\n   * @internal\n   */\n  pauseFocusOut() {\n    this.play();\n  }\n  /**\n   * Rolling to specified slide\n   * @param index: {number} index of slide, which must be shown\n   */\n  selectSlide(index) {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n    if (!this.multilist) {\n      this.activeSlide = this.indicatorsByChunk ? index * this.itemsPerSlide : index;\n    } else {\n      this.selectSlideRange(this.indicatorsByChunk ? index * this.itemsPerSlide : index);\n    }\n  }\n  /**\n   * Starts a auto changing of slides\n   */\n  play() {\n    if (!this.isPlaying) {\n      this.isPlaying = true;\n      this.restartTimer();\n    }\n  }\n  /**\n   * Stops a auto changing of slides\n   */\n  pause() {\n    if (!this.noPause) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n  /**\n   * Finds and returns index of currently displayed slide\n   */\n  getCurrentSlideIndex() {\n    return this._slides.findIndex(this.getActive);\n  }\n  /**\n   * Defines, whether the specified index is last in collection\n   * @param index\n   */\n  isLast(index) {\n    return index + 1 >= this._slides.length;\n  }\n  /**\n   * Defines, whether the specified index is first in collection\n   * @param index\n   */\n  isFirst(index) {\n    return index === 0;\n  }\n  indicatorsSlides() {\n    return this.slides.filter((slide, index) => !this.indicatorsByChunk || index % this.itemsPerSlide === 0);\n  }\n  selectInitialSlides() {\n    const startIndex = this.startFromIndex <= this._slides.length ? this.startFromIndex : 0;\n    this.hideSlides();\n    if (this.singleSlideOffset) {\n      this._slidesWithIndexes = this.mapSlidesAndIndexes();\n      if (this._slides.length - startIndex < this.itemsPerSlide) {\n        const slidesToAppend = this._slidesWithIndexes.slice(0, startIndex);\n        this._slidesWithIndexes = [...this._slidesWithIndexes, ...slidesToAppend].slice(slidesToAppend.length).slice(0, this.itemsPerSlide);\n      } else {\n        this._slidesWithIndexes = this._slidesWithIndexes.slice(startIndex, startIndex + this.itemsPerSlide);\n      }\n      this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n    } else {\n      this.selectRangeByNestedIndex(startIndex);\n    }\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n  /**\n   * Defines next slide index, depending of direction\n   * @param direction: Direction(UNKNOWN|PREV|NEXT)\n   * @param force: {boolean} if TRUE - will ignore noWrap flag, else will\n   *   return undefined if next slide require wrapping\n   */\n  findNextSlideIndex(direction, force) {\n    let nextSlideIndex = 0;\n    if (!force && this.isLast(this.activeSlide) && direction !== Direction.PREV && this.noWrap) {\n      return;\n    }\n    switch (direction) {\n      case Direction.NEXT:\n        // if this is last slide, not force, looping is disabled\n        // and need to going forward - select current slide, as a next\n        if (typeof this._currentActiveSlide === 'undefined') {\n          nextSlideIndex = 0;\n          break;\n        }\n        if (!this.isLast(this._currentActiveSlide)) {\n          nextSlideIndex = this._currentActiveSlide + 1;\n          break;\n        }\n        nextSlideIndex = !force && this.noWrap ? this._currentActiveSlide : 0;\n        break;\n      case Direction.PREV:\n        // if this is first slide, not force, looping is disabled\n        // and need to going backward - select current slide, as a next\n        if (typeof this._currentActiveSlide === 'undefined') {\n          nextSlideIndex = 0;\n          break;\n        }\n        if (this._currentActiveSlide > 0) {\n          nextSlideIndex = this._currentActiveSlide - 1;\n          break;\n        }\n        if (!force && this.noWrap) {\n          nextSlideIndex = this._currentActiveSlide;\n          break;\n        }\n        nextSlideIndex = this._slides.length - 1;\n        break;\n      default:\n        throw new Error('Unknown direction');\n    }\n    return nextSlideIndex;\n  }\n  mapSlidesAndIndexes() {\n    return this.slides.slice().map((slide, index) => {\n      return {\n        index,\n        item: slide\n      };\n    });\n  }\n  selectSlideRange(index) {\n    if (this.isIndexInRange(index)) {\n      return;\n    }\n    this.hideSlides();\n    if (!this.singleSlideOffset) {\n      this.selectRangeByNestedIndex(index);\n    } else {\n      const startIndex = this.isIndexOnTheEdges(index) ? index : index - this.itemsPerSlide + 1;\n      const endIndex = this.isIndexOnTheEdges(index) ? index + this.itemsPerSlide : index + 1;\n      this._slidesWithIndexes = this.mapSlidesAndIndexes().slice(startIndex, endIndex);\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n      this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n    }\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n  selectRangeByNestedIndex(index) {\n    if (!this._chunkedSlides) {\n      return;\n    }\n    const selectedRange = this._chunkedSlides.map((slidesList, i) => {\n      return {\n        index: i,\n        list: slidesList\n      };\n    }).find(slidesList => {\n      return slidesList.list.find(slide => slide.index === index) !== undefined;\n    });\n    if (!selectedRange) {\n      return;\n    }\n    this._currentVisibleSlidesIndex = selectedRange.index;\n    this._chunkedSlides[selectedRange.index].forEach(slide => {\n      slide.item.active = true;\n    });\n  }\n  isIndexOnTheEdges(index) {\n    return index + 1 - this.itemsPerSlide <= 0 || index + this.itemsPerSlide <= this._slides.length;\n  }\n  isIndexInRange(index) {\n    if (this.singleSlideOffset && this._slidesWithIndexes) {\n      const visibleIndexes = this._slidesWithIndexes.map(slide => slide.index);\n      return visibleIndexes.indexOf(index) >= 0;\n    }\n    return index <= this.getLastVisibleIndex() && index >= this.getFirstVisibleIndex();\n  }\n  hideSlides() {\n    this.slides.forEach(slide => slide.active = false);\n  }\n  isVisibleSlideListLast() {\n    if (!this._chunkedSlides) {\n      return false;\n    }\n    return this._currentVisibleSlidesIndex === this._chunkedSlides.length - 1;\n  }\n  isVisibleSlideListFirst() {\n    return this._currentVisibleSlidesIndex === 0;\n  }\n  moveSliderByOneItem(direction) {\n    let firstVisibleIndex;\n    let lastVisibleIndex;\n    let indexToHide;\n    let indexToShow;\n    if (this.noWrap) {\n      firstVisibleIndex = this.getFirstVisibleIndex();\n      lastVisibleIndex = this.getLastVisibleIndex();\n      indexToHide = direction === Direction.NEXT ? firstVisibleIndex : lastVisibleIndex;\n      indexToShow = direction !== Direction.NEXT ? firstVisibleIndex - 1 : !this.isLast(lastVisibleIndex) ? lastVisibleIndex + 1 : 0;\n      const slideToHide = this._slides.get(indexToHide);\n      if (slideToHide) {\n        slideToHide.active = false;\n      }\n      const slideToShow = this._slides.get(indexToShow);\n      if (slideToShow) {\n        slideToShow.active = true;\n      }\n      const slidesToReorder = this.mapSlidesAndIndexes().filter(slide => slide.item.active);\n      this.makeSlidesConsistent(slidesToReorder);\n      if (this.singleSlideOffset) {\n        this._slidesWithIndexes = slidesToReorder;\n      }\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n      return;\n    }\n    if (!this._slidesWithIndexes || !this._slidesWithIndexes[0]) {\n      return;\n    }\n    let index;\n    firstVisibleIndex = this._slidesWithIndexes[0].index;\n    lastVisibleIndex = this._slidesWithIndexes[this._slidesWithIndexes.length - 1].index;\n    if (direction === Direction.NEXT) {\n      this._slidesWithIndexes.shift();\n      index = this.isLast(lastVisibleIndex) ? 0 : lastVisibleIndex + 1;\n      const item = this._slides.get(index);\n      if (item) {\n        this._slidesWithIndexes.push({\n          index,\n          item\n        });\n      }\n    } else {\n      this._slidesWithIndexes.pop();\n      index = this.isFirst(firstVisibleIndex) ? this._slides.length - 1 : firstVisibleIndex - 1;\n      const item = this._slides.get(index);\n      if (item) {\n        this._slidesWithIndexes = [{\n          index,\n          item\n        }, ...this._slidesWithIndexes];\n      }\n    }\n    this.hideSlides();\n    this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n    this.makeSlidesConsistent(this._slidesWithIndexes);\n    this.slideRangeChange.emit(this._slidesWithIndexes.map(slide => slide.index));\n  }\n  moveMultilist(direction) {\n    if (this.singleSlideOffset) {\n      this.moveSliderByOneItem(direction);\n    } else {\n      this.hideSlides();\n      if (this.noWrap) {\n        this._currentVisibleSlidesIndex = direction === Direction.NEXT ? this._currentVisibleSlidesIndex + 1 : this._currentVisibleSlidesIndex - 1;\n      } else if (direction === Direction.NEXT) {\n        this._currentVisibleSlidesIndex = this.isVisibleSlideListLast() ? 0 : this._currentVisibleSlidesIndex + 1;\n      } else {\n        if (this.isVisibleSlideListFirst()) {\n          this._currentVisibleSlidesIndex = this._chunkedSlides ? this._chunkedSlides.length - 1 : 0;\n        } else {\n          this._currentVisibleSlidesIndex = this._currentVisibleSlidesIndex - 1;\n        }\n      }\n      if (this._chunkedSlides) {\n        this._chunkedSlides[this._currentVisibleSlidesIndex].forEach(slide => slide.item.active = true);\n      }\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n  }\n  getVisibleIndexes() {\n    if (!this.singleSlideOffset && this._chunkedSlides) {\n      return this._chunkedSlides[this._currentVisibleSlidesIndex].map(slide => slide.index);\n    }\n    if (this._slidesWithIndexes) {\n      return this._slidesWithIndexes.map(slide => slide.index);\n    }\n  }\n  /**\n   * Sets a slide, which specified through index, as active\n   * @param index\n   */\n  _select(index) {\n    if (isNaN(index)) {\n      this.pause();\n      return;\n    }\n    if (!this.multilist && typeof this._currentActiveSlide !== 'undefined') {\n      const currentSlide = this._slides.get(this._currentActiveSlide);\n      if (typeof currentSlide !== 'undefined') {\n        currentSlide.active = false;\n      }\n    }\n    const nextSlide = this._slides.get(index);\n    if (typeof nextSlide !== 'undefined') {\n      this._currentActiveSlide = index;\n      nextSlide.active = true;\n      this.activeSlide = index;\n      this.activeSlideChange.emit(index);\n    }\n  }\n  /**\n   * Starts loop of auto changing of slides\n   */\n  restartTimer() {\n    this.resetTimer();\n    const interval = +this.interval;\n    if (!isNaN(interval) && interval > 0 && isPlatformBrowser(this.platformId)) {\n      this.currentInterval = this.ngZone.runOutsideAngular(() => {\n        return window.setInterval(() => {\n          const nInterval = +this.interval;\n          this.ngZone.run(() => {\n            if (this.isPlaying && !isNaN(this.interval) && nInterval > 0 && this.slides.length) {\n              this.nextSlideFromInterval();\n            } else {\n              this.pause();\n            }\n          });\n        }, interval);\n      });\n    }\n  }\n  get multilist() {\n    return this.itemsPerSlide > 1;\n  }\n  /**\n   * Stops loop of auto changing of slides\n   */\n  resetTimer() {\n    if (this.currentInterval) {\n      clearInterval(this.currentInterval);\n      this.currentInterval = void 0;\n    }\n  }\n  checkDisabledClass(buttonType) {\n    if (buttonType === 'prev') {\n      return this.activeSlide === 0 && this.noWrap && !this.multilist || this.isFirstSlideVisible && this.noWrap && this.multilist;\n    }\n    return this.isLast(this.activeSlide) && this.noWrap && !this.multilist || this.isLastSlideVisible && this.noWrap && this.multilist;\n  }\n  static #_ = this.ɵfac = function CarouselComponent_Factory(t) {\n    return new (t || CarouselComponent)(i0.ɵɵdirectiveInject(CarouselConfig), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(PLATFORM_ID));\n  };\n  static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CarouselComponent,\n    selectors: [[\"carousel\"]],\n    inputs: {\n      noWrap: \"noWrap\",\n      noPause: \"noPause\",\n      showIndicators: \"showIndicators\",\n      pauseOnFocus: \"pauseOnFocus\",\n      indicatorsByChunk: \"indicatorsByChunk\",\n      itemsPerSlide: \"itemsPerSlide\",\n      singleSlideOffset: \"singleSlideOffset\",\n      isAnimated: \"isAnimated\",\n      activeSlide: \"activeSlide\",\n      startFromIndex: \"startFromIndex\",\n      interval: \"interval\"\n    },\n    outputs: {\n      activeSlideChange: \"activeSlideChange\",\n      slideRangeChange: \"slideRangeChange\"\n    },\n    ngContentSelectors: _c1,\n    decls: 7,\n    vars: 8,\n    consts: [[\"tabindex\", \"0\", 1, \"carousel\", \"slide\", 3, \"id\", \"mouseenter\", \"mouseleave\", \"mouseup\", \"keydown\", \"focusin\", \"focusout\"], [4, \"ngIf\"], [1, \"carousel-inner\", 3, \"ngStyle\"], [\"class\", \"left carousel-control carousel-control-prev\", \"href\", \"javascript:void(0);\", \"tabindex\", \"0\", \"role\", \"button\", 3, \"disabled\", \"click\", 4, \"ngIf\"], [\"class\", \"right carousel-control carousel-control-next\", \"href\", \"javascript:void(0);\", \"tabindex\", \"0\", \"role\", \"button\", 3, \"disabled\", \"click\", 4, \"ngIf\"], [1, \"carousel-indicators\"], [3, \"active\", \"click\", 4, \"ngFor\", \"ngForOf\"], [3, \"click\"], [\"type\", \"button\", \"aria-current\", \"true\", 3, \"active\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"type\", \"button\", \"aria-current\", \"true\", 3, \"click\"], [\"href\", \"javascript:void(0);\", \"tabindex\", \"0\", \"role\", \"button\", 1, \"left\", \"carousel-control\", \"carousel-control-prev\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"icon-prev\", \"carousel-control-prev-icon\"], [1, \"sr-only\", \"visually-hidden\"], [\"href\", \"javascript:void(0);\", \"tabindex\", \"0\", \"role\", \"button\", 1, \"right\", \"carousel-control\", \"carousel-control-next\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"icon-next\", \"carousel-control-next-icon\"]],\n    template: function CarouselComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵlistener(\"mouseenter\", function CarouselComponent_Template_div_mouseenter_0_listener() {\n          return ctx.pause();\n        })(\"mouseleave\", function CarouselComponent_Template_div_mouseleave_0_listener() {\n          return ctx.onMouseLeave();\n        })(\"mouseup\", function CarouselComponent_Template_div_mouseup_0_listener() {\n          return ctx.onMouseUp();\n        })(\"keydown\", function CarouselComponent_Template_div_keydown_0_listener($event) {\n          return ctx.keydownPress($event);\n        })(\"focusin\", function CarouselComponent_Template_div_focusin_0_listener() {\n          return ctx.pauseFocusIn();\n        })(\"focusout\", function CarouselComponent_Template_div_focusout_0_listener() {\n          return ctx.pauseFocusOut();\n        });\n        i0.ɵɵtemplate(1, CarouselComponent_ng_container_1_Template, 3, 1, \"ng-container\", 1)(2, CarouselComponent_ng_container_2_Template, 3, 1, \"ng-container\", 1);\n        i0.ɵɵelementStart(3, \"div\", 2);\n        i0.ɵɵprojection(4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(5, CarouselComponent_a_5_Template, 4, 3, \"a\", 3)(6, CarouselComponent_a_6_Template, 4, 3, \"a\", 4);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"id\", \"carousel\" + ctx.currentId);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx._bsVer.isBs5 && ctx.showIndicators && ctx.slides.length > 1);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx._bsVer.isBs5 && ctx.showIndicators && ctx.slides.length > 1);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction1(6, _c0, ctx.multilist ? \"flex\" : \"block\"));\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.slides.length > 1);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.slides.length > 1);\n      }\n    },\n    dependencies: [i2.NgForOf, i2.NgIf, i2.NgStyle],\n    encapsulation: 2\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CarouselComponent, [{\n    type: Component,\n    args: [{\n      selector: 'carousel',\n      template: \"<div (mouseenter)=\\\"pause()\\\"\\n     (mouseleave)=\\\"onMouseLeave()\\\"\\n     (mouseup)=\\\"onMouseUp()\\\"\\n     (keydown)=\\\"keydownPress($event)\\\"\\n     (focusin)=\\\"pauseFocusIn()\\\"\\n     (focusout)=\\\"pauseFocusOut()\\\"\\n     [id]=\\\"'carousel' + currentId\\\"\\n     class=\\\"carousel slide\\\" tabindex=\\\"0\\\">\\n  <ng-container *ngIf=\\\"!_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <ol class=\\\"carousel-indicators\\\">\\n      <li *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n          [class.active]=\\\"slide.active === true\\\"\\n          (click)=\\\"selectSlide(i)\\\">\\n      </li>\\n    </ol>\\n  </ng-container>\\n  <ng-container *ngIf=\\\"_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <div class=\\\"carousel-indicators\\\">\\n      <button\\n        *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n        [class.active]=\\\"slide.active === true\\\"\\n        (click)=\\\"selectSlide(i)\\\"\\n        type=\\\"button\\\"\\n        [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n        [attr.data-bs-slide-to]=\\\"i\\\" aria-current=\\\"true\\\"\\n      >\\n      </button>\\n    </div>\\n  </ng-container>\\n  <div class=\\\"carousel-inner\\\" [ngStyle]=\\\"{'display': multilist ? 'flex' : 'block'}\\\">\\n    <ng-content></ng-content>\\n  </div>\\n  <a class=\\\"left carousel-control carousel-control-prev\\\"\\n     href=\\\"javascript:void(0);\\\"\\n     [class.disabled]=\\\"checkDisabledClass('prev')\\\"\\n     [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     (click)=\\\"previousSlide()\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-prev carousel-control-prev-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Previous</span>\\n  </a>\\n\\n  <a class=\\\"right carousel-control carousel-control-next\\\"\\n     href=\\\"javascript:void(0);\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     (click)=\\\"nextSlide()\\\"\\n     [class.disabled]=\\\"checkDisabledClass('next')\\\"\\n     [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-next carousel-control-next-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Next</span>\\n  </a>\\n</div>\\n\"\n    }]\n  }], () => [{\n    type: CarouselConfig\n  }, {\n    type: i0.NgZone\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [PLATFORM_ID]\n    }]\n  }], {\n    noWrap: [{\n      type: Input\n    }],\n    noPause: [{\n      type: Input\n    }],\n    showIndicators: [{\n      type: Input\n    }],\n    pauseOnFocus: [{\n      type: Input\n    }],\n    indicatorsByChunk: [{\n      type: Input\n    }],\n    itemsPerSlide: [{\n      type: Input\n    }],\n    singleSlideOffset: [{\n      type: Input\n    }],\n    isAnimated: [{\n      type: Input\n    }],\n    activeSlideChange: [{\n      type: Output\n    }],\n    slideRangeChange: [{\n      type: Output\n    }],\n    activeSlide: [{\n      type: Input\n    }],\n    startFromIndex: [{\n      type: Input\n    }],\n    interval: [{\n      type: Input\n    }]\n  });\n})();\nclass SlideComponent {\n  constructor(carousel) {\n    /** Is current slide active */\n    this.active = false;\n    this.itemWidth = '100%';\n    this.order = 0;\n    this.isAnimated = false;\n    /** Wraps element by appropriate CSS classes */\n    this.addClass = true;\n    this.multilist = false;\n    this.carousel = carousel;\n  }\n  /** Fires changes in container collection after adding a new slide instance */\n  ngOnInit() {\n    this.carousel.addSlide(this);\n    this.itemWidth = `${100 / this.carousel.itemsPerSlide}%`;\n    this.multilist = this.carousel?.itemsPerSlide > 1;\n  }\n  /** Fires changes in container collection after removing of this slide instance */\n  ngOnDestroy() {\n    this.carousel.removeSlide(this);\n  }\n  static #_ = this.ɵfac = function SlideComponent_Factory(t) {\n    return new (t || SlideComponent)(i0.ɵɵdirectiveInject(CarouselComponent));\n  };\n  static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SlideComponent,\n    selectors: [[\"slide\"]],\n    hostVars: 15,\n    hostBindings: function SlideComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-hidden\", !ctx.active);\n        i0.ɵɵstyleProp(\"width\", ctx.itemWidth)(\"order\", ctx.order);\n        i0.ɵɵclassProp(\"multilist-margin\", ctx.multilist)(\"active\", ctx.active)(\"carousel-animation\", ctx.isAnimated)(\"item\", ctx.addClass)(\"carousel-item\", ctx.addClass);\n      }\n    },\n    inputs: {\n      active: \"active\"\n    },\n    ngContentSelectors: _c1,\n    decls: 2,\n    vars: 2,\n    consts: [[1, \"item\"]],\n    template: function SlideComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵprojection(1);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"active\", ctx.active);\n      }\n    },\n    styles: [\".carousel-animation[_nghost-%COMP%]{transition:opacity .6s ease,visibility .6s ease;float:left}.carousel-animation.active[_nghost-%COMP%]{opacity:1;visibility:visible}.carousel-animation[_nghost-%COMP%]:not(.active){display:block;position:absolute;opacity:0;visibility:hidden}.multilist-margin[_nghost-%COMP%]{margin-right:auto}.carousel-item[_nghost-%COMP%]{perspective:1000px}\"]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SlideComponent, [{\n    type: Component,\n    args: [{\n      selector: 'slide',\n      template: `\n    <div [class.active]=\"active\" class=\"item\">\n      <ng-content></ng-content>\n    </div>\n  `,\n      host: {\n        '[attr.aria-hidden]': '!active',\n        '[class.multilist-margin]': 'multilist'\n      },\n      styles: [\":host.carousel-animation{transition:opacity .6s ease,visibility .6s ease;float:left}:host.carousel-animation.active{opacity:1;visibility:visible}:host.carousel-animation:not(.active){display:block;position:absolute;opacity:0;visibility:hidden}:host.multilist-margin{margin-right:auto}:host.carousel-item{perspective:1000px}\\n\"]\n    }]\n  }], () => [{\n    type: CarouselComponent\n  }], {\n    active: [{\n      type: HostBinding,\n      args: ['class.active']\n    }, {\n      type: Input\n    }],\n    itemWidth: [{\n      type: HostBinding,\n      args: ['style.width']\n    }],\n    order: [{\n      type: HostBinding,\n      args: ['style.order']\n    }],\n    isAnimated: [{\n      type: HostBinding,\n      args: ['class.carousel-animation']\n    }],\n    addClass: [{\n      type: HostBinding,\n      args: ['class.item']\n    }, {\n      type: HostBinding,\n      args: ['class.carousel-item']\n    }]\n  });\n})();\nclass CarouselModule {\n  static forRoot() {\n    return {\n      ngModule: CarouselModule,\n      providers: []\n    };\n  }\n  static #_ = this.ɵfac = function CarouselModule_Factory(t) {\n    return new (t || CarouselModule)();\n  };\n  static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CarouselModule\n  });\n  static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CarouselModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule],\n      declarations: [SlideComponent, CarouselComponent],\n      exports: [SlideComponent, CarouselComponent]\n    }]\n  }], null, null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CarouselComponent, CarouselConfig, CarouselModule, SlideComponent };","map":{"version":3,"names":["i0","Injectable","EventEmitter","PLATFORM_ID","Component","Inject","Input","Output","HostBinding","NgModule","i2","isPlatformBrowser","CommonModule","getBsVer","LinkedList","CarouselComponent_ng_container_1_li_2_Template","rf","ctx","_r8","ɵɵgetCurrentView","ɵɵelementStart","ɵɵlistener","CarouselComponent_ng_container_1_li_2_Template_li_click_0_listener","restoredCtx","ɵɵrestoreView","i_r6","index","ctx_r7","ɵɵnextContext","ɵɵresetView","selectSlide","ɵɵelementEnd","slide_r5","$implicit","ɵɵclassProp","active","CarouselComponent_ng_container_1_Template","ɵɵelementContainerStart","ɵɵtemplate","ɵɵelementContainerEnd","ctx_r0","ɵɵadvance","ɵɵproperty","indicatorsSlides","CarouselComponent_ng_container_2_button_2_Template","_r13","CarouselComponent_ng_container_2_button_2_Template_button_click_0_listener","i_r11","ctx_r12","slide_r10","ctx_r9","ɵɵattribute","currentId","CarouselComponent_ng_container_2_Template","ctx_r1","CarouselComponent_a_5_Template","_r15","CarouselComponent_a_5_Template_a_click_0_listener","ctx_r14","previousSlide","ɵɵelement","ɵɵtext","ctx_r2","checkDisabledClass","CarouselComponent_a_6_Template","_r17","CarouselComponent_a_6_Template_a_click_0_listener","ctx_r16","nextSlide","ctx_r3","_c0","a0","_c1","CarouselConfig","constructor","interval","noPause","noWrap","showIndicators","pauseOnFocus","indicatorsByChunk","itemsPerSlide","singleSlideOffset","_","ɵfac","CarouselConfig_Factory","t","_2","ɵprov","ɵɵdefineInjectable","token","factory","providedIn","ngDevMode","ɵsetClassMetadata","type","args","findLastIndex","array","predicate","l","length","chunkByNumber","size","out","n","Math","ceil","i","chunk","splice","push","isNumber","value","Object","prototype","toString","call","Direction","_currentId","CarouselComponent","activeSlide","multilist","customActiveSlide","_slides","_currentActiveSlide","_select","_interval","restartTimer","slides","toArray","isFirstSlideVisible","indexes","getVisibleIndexes","Array","includes","isLastSlideVisible","_bsVer","config","ngZone","platformId","isAnimated","activeSlideChange","slideRangeChange","startFromIndex","_currentVisibleSlidesIndex","isPlaying","destroyed","getActive","slide","makeSlidesConsistent","forEach","item","order","assign","ngAfterViewInit","setTimeout","_chunkedSlides","mapSlidesAndIndexes","selectInitialSlides","ngOnDestroy","addSlide","add","undefined","play","removeSlide","remIndex","indexOf","nextSlideIndex","isLast","remove","currentSlideIndex","getCurrentSlideIndex","emit","nextSlideFromInterval","force","move","NEXT","PREV","getFirstVisibleIndex","findIndex","getLastVisibleIndex","direction","firstVisibleIndex","lastVisibleIndex","findNextSlideIndex","moveMultilist","keydownPress","event","keyCode","key","preventDefault","onMouseLeave","onMouseUp","pauseFocusIn","resetTimer","pauseFocusOut","selectSlideRange","pause","isFirst","filter","startIndex","hideSlides","_slidesWithIndexes","slidesToAppend","slice","selectRangeByNestedIndex","Error","map","isIndexInRange","isIndexOnTheEdges","endIndex","selectedRange","slidesList","list","find","visibleIndexes","isVisibleSlideListLast","isVisibleSlideListFirst","moveSliderByOneItem","indexToHide","indexToShow","slideToHide","get","slideToShow","slidesToReorder","shift","pop","isNaN","currentSlide","currentInterval","runOutsideAngular","window","setInterval","nInterval","run","clearInterval","buttonType","CarouselComponent_Factory","ɵɵdirectiveInject","NgZone","ɵcmp","ɵɵdefineComponent","selectors","inputs","outputs","ngContentSelectors","decls","vars","consts","template","CarouselComponent_Template","ɵɵprojectionDef","CarouselComponent_Template_div_mouseenter_0_listener","CarouselComponent_Template_div_mouseleave_0_listener","CarouselComponent_Template_div_mouseup_0_listener","CarouselComponent_Template_div_keydown_0_listener","$event","CarouselComponent_Template_div_focusin_0_listener","CarouselComponent_Template_div_focusout_0_listener","ɵɵprojection","isBs5","ɵɵpureFunction1","dependencies","NgForOf","NgIf","NgStyle","encapsulation","selector","decorators","SlideComponent","carousel","itemWidth","addClass","ngOnInit","SlideComponent_Factory","hostVars","hostBindings","SlideComponent_HostBindings","ɵɵstyleProp","SlideComponent_Template","styles","host","CarouselModule","forRoot","ngModule","providers","CarouselModule_Factory","ɵmod","ɵɵdefineNgModule","_3","ɵinj","ɵɵdefineInjector","imports","declarations","exports"],"sources":["/Users/moha/Desktop/cliniqueDentaire/joseph/node_modules/ngx-bootstrap/carousel/fesm2022/ngx-bootstrap-carousel.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, PLATFORM_ID, Component, Inject, Input, Output, HostBinding, NgModule } from '@angular/core';\nimport * as i2 from '@angular/common';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { getBsVer, LinkedList } from 'ngx-bootstrap/utils';\n\nclass CarouselConfig {\n    constructor() {\n        /* Default interval of auto changing of slides */\n        this.interval = 5000;\n        /* Is loop of auto changing of slides can be paused */\n        this.noPause = false;\n        /* Is slides can wrap from the last to the first slide */\n        this.noWrap = false;\n        /* Show carousel-indicators */\n        this.showIndicators = true;\n        /* Slides can be paused on focus */\n        this.pauseOnFocus = false;\n        /* If `true` - carousel indicators indicate slides chunks works ONLY if singleSlideOffset = FALSE */\n        this.indicatorsByChunk = false;\n        /* If value more then 1 — carousel works in multilist mode */\n        this.itemsPerSlide = 1;\n        /* If `true` — carousel shifts by one element. By default carousel shifts by number\n          of visible elements (itemsPerSlide field) */\n        this.singleSlideOffset = false;\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CarouselConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CarouselConfig, providedIn: 'root' }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CarouselConfig, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }] });\n\n/**\n * Returns the index of the last element in the array where predicate is true, and -1\n * otherwise.\n * @param array The source array to search in\n * @param predicate find calls predicate once for each element of the array, in descending\n * order, until it finds one where predicate returns true. If such an element is found,\n * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n */\nfunction findLastIndex(array, predicate) {\n    let l = array.length;\n    while (l--) {\n        if (predicate(array[l], l, array)) {\n            return l;\n        }\n    }\n    return -1;\n}\nfunction chunkByNumber(array, size) {\n    const out = [];\n    const n = Math.ceil(array.length / size);\n    let i = 0;\n    while (i < n) {\n        const chunk = array.splice(0, i === n - 1 && size < array.length ? array.length : size);\n        out.push(chunk);\n        i++;\n    }\n    return out;\n}\nfunction isNumber(value) {\n    return typeof value === 'number' || Object.prototype.toString.call(value) === '[object Number]';\n}\n\n/***\n * pause (not yet supported) (?string='hover') - event group name which pauses\n * the cycling of the carousel, if hover pauses on mouseenter and resumes on\n * mouseleave keyboard (not yet supported) (?boolean=true) - if false\n * carousel will not react to keyboard events\n * note: swiping not yet supported\n */\n/****\n * Problems:\n * 1) if we set an active slide via model changes, .active class remains on a\n * current slide.\n * 2) if we have only one slide, we shouldn't show prev/next nav buttons\n * 3) if first or last slide is active and noWrap is true, there should be\n * \"disabled\" class on the nav buttons.\n * 4) default interval should be equal 5000\n */\nvar Direction;\n(function (Direction) {\n    Direction[Direction[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    Direction[Direction[\"NEXT\"] = 1] = \"NEXT\";\n    Direction[Direction[\"PREV\"] = 2] = \"PREV\";\n})(Direction || (Direction = {}));\nlet _currentId = 1;\n/**\n * Base element to create carousel\n */\nclass CarouselComponent {\n    /** Index of currently displayed slide(started for 0) */\n    set activeSlide(index) {\n        if (this.multilist) {\n            return;\n        }\n        if (isNumber(index)) {\n            this.customActiveSlide = index;\n        }\n        if (this._slides.length && index !== this._currentActiveSlide) {\n            this._select(index);\n        }\n    }\n    get activeSlide() {\n        return this._currentActiveSlide || 0;\n    }\n    /**\n     * Delay of item cycling in milliseconds. If false, carousel won't cycle\n     * automatically.\n     */\n    get interval() {\n        return this._interval;\n    }\n    set interval(value) {\n        this._interval = value;\n        this.restartTimer();\n    }\n    get slides() {\n        return this._slides.toArray();\n    }\n    get isFirstSlideVisible() {\n        const indexes = this.getVisibleIndexes();\n        if (!indexes || (indexes instanceof Array && !indexes.length)) {\n            return false;\n        }\n        return indexes.includes(0);\n    }\n    get isLastSlideVisible() {\n        const indexes = this.getVisibleIndexes();\n        if (!indexes || (indexes instanceof Array && !indexes.length)) {\n            return false;\n        }\n        return indexes.includes(this._slides.length - 1);\n    }\n    get _bsVer() {\n        return getBsVer();\n    }\n    constructor(config, ngZone, platformId) {\n        this.ngZone = ngZone;\n        this.platformId = platformId;\n        /* If `true` — carousel will not cycle continuously and will have hard stops (prevent looping) */\n        this.noWrap = false;\n        /*  If `true` — will disable pausing on carousel mouse hover */\n        this.noPause = false;\n        /*  If `true` — carousel-indicators are visible  */\n        this.showIndicators = true;\n        /*  If `true` - autoplay will be stopped on focus */\n        this.pauseOnFocus = false;\n        /* If `true` - carousel indicators indicate slides chunks\n           works ONLY if singleSlideOffset = FALSE */\n        this.indicatorsByChunk = false;\n        /* If value more then 1 — carousel works in multilist mode */\n        this.itemsPerSlide = 1;\n        /* If `true` — carousel shifts by one element. By default carousel shifts by number\n           of visible elements (itemsPerSlide field) */\n        this.singleSlideOffset = false;\n        /** Turn on/off animation. Animation doesn't work for multilist carousel */\n        this.isAnimated = false;\n        /** Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property */\n        this.activeSlideChange = new EventEmitter(false);\n        /** Will be emitted when active slides has been changed in multilist mode */\n        this.slideRangeChange = new EventEmitter();\n        /* Index to start display slides from it */\n        this.startFromIndex = 0;\n        this._interval = 5000;\n        this._slides = new LinkedList();\n        this._currentVisibleSlidesIndex = 0;\n        this.isPlaying = false;\n        this.destroyed = false;\n        this.currentId = 0;\n        this.getActive = (slide) => slide.active;\n        this.makeSlidesConsistent = (slides) => {\n            slides.forEach((slide, index) => slide.item.order = index);\n        };\n        Object.assign(this, config);\n        this.currentId = _currentId++;\n    }\n    ngAfterViewInit() {\n        setTimeout(() => {\n            if (this.singleSlideOffset) {\n                this.indicatorsByChunk = false;\n            }\n            if (this.multilist) {\n                this._chunkedSlides = chunkByNumber(this.mapSlidesAndIndexes(), this.itemsPerSlide);\n                this.selectInitialSlides();\n            }\n            if (this.customActiveSlide && !this.multilist) {\n                this._select(this.customActiveSlide);\n            }\n        }, 0);\n    }\n    ngOnDestroy() {\n        this.destroyed = true;\n    }\n    /**\n     * Adds new slide. If this slide is first in collection - set it as active\n     * and starts auto changing\n     * @param slide\n     */\n    addSlide(slide) {\n        this._slides.add(slide);\n        if (this.multilist && this._slides.length <= this.itemsPerSlide) {\n            slide.active = true;\n        }\n        if (!this.multilist && this.isAnimated) {\n            slide.isAnimated = true;\n        }\n        if (!this.multilist && this._slides.length === 1) {\n            this._currentActiveSlide = undefined;\n            if (!this.customActiveSlide) {\n                this.activeSlide = 0;\n            }\n            this.play();\n        }\n        if (this.multilist && this._slides.length > this.itemsPerSlide) {\n            this.play();\n        }\n    }\n    /**\n     * Removes specified slide. If this slide is active - will roll to another\n     * slide\n     * @param slide\n     */\n    removeSlide(slide) {\n        const remIndex = this._slides.indexOf(slide);\n        if (this._currentActiveSlide === remIndex) {\n            // removing of active slide\n            let nextSlideIndex;\n            if (this._slides.length > 1) {\n                // if this slide last - will roll to first slide, if noWrap flag is\n                // FALSE or to previous, if noWrap is TRUE in case, if this slide in\n                // middle of collection, index of next slide is same to removed\n                nextSlideIndex = !this.isLast(remIndex)\n                    ? remIndex\n                    : this.noWrap ? remIndex - 1 : 0;\n            }\n            this._slides.remove(remIndex);\n            // prevents exception with changing some value after checking\n            setTimeout(() => {\n                this._select(nextSlideIndex);\n            }, 0);\n        }\n        else {\n            this._slides.remove(remIndex);\n            const currentSlideIndex = this.getCurrentSlideIndex();\n            setTimeout(() => {\n                // after removing, need to actualize index of current active slide\n                this._currentActiveSlide = currentSlideIndex;\n                this.activeSlideChange.emit(this._currentActiveSlide);\n            }, 0);\n        }\n    }\n    nextSlideFromInterval(force = false) {\n        this.move(Direction.NEXT, force);\n    }\n    /**\n     * Rolling to next slide\n     * @param force: {boolean} if true - will ignore noWrap flag\n     */\n    nextSlide(force = false) {\n        if (this.isPlaying) {\n            this.restartTimer();\n        }\n        this.move(Direction.NEXT, force);\n    }\n    /**\n     * Rolling to previous slide\n     * @param force: {boolean} if true - will ignore noWrap flag\n     */\n    previousSlide(force = false) {\n        if (this.isPlaying) {\n            this.restartTimer();\n        }\n        this.move(Direction.PREV, force);\n    }\n    getFirstVisibleIndex() {\n        return this.slides.findIndex(this.getActive);\n    }\n    getLastVisibleIndex() {\n        return findLastIndex(this.slides, this.getActive);\n    }\n    move(direction, force = false) {\n        const firstVisibleIndex = this.getFirstVisibleIndex();\n        const lastVisibleIndex = this.getLastVisibleIndex();\n        if (this.noWrap) {\n            if (direction === Direction.NEXT &&\n                this.isLast(lastVisibleIndex) ||\n                direction === Direction.PREV &&\n                    firstVisibleIndex === 0) {\n                return;\n            }\n        }\n        if (!this.multilist) {\n            this.activeSlide = this.findNextSlideIndex(direction, force) || 0;\n        }\n        else {\n            this.moveMultilist(direction);\n        }\n    }\n    /**\n     * Swith slides by enter, space and arrows keys\n     * @internal\n     */\n    keydownPress(event) {\n        if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n            this.nextSlide();\n            event.preventDefault();\n            return;\n        }\n        if (event.keyCode === 37 || event.key === 'LeftArrow') {\n            this.previousSlide();\n            return;\n        }\n        if (event.keyCode === 39 || event.key === 'RightArrow') {\n            this.nextSlide();\n            return;\n        }\n    }\n    /**\n     * Play on mouse leave\n     * @internal\n     */\n    onMouseLeave() {\n        if (!this.pauseOnFocus) {\n            this.play();\n        }\n    }\n    /**\n     * Play on mouse up\n     * @internal\n     */\n    onMouseUp() {\n        if (!this.pauseOnFocus) {\n            this.play();\n        }\n    }\n    /**\n     * When slides on focus autoplay is stopped(optional)\n     * @internal\n     */\n    pauseFocusIn() {\n        if (this.pauseOnFocus) {\n            this.isPlaying = false;\n            this.resetTimer();\n        }\n    }\n    /**\n     * When slides out of focus autoplay is started\n     * @internal\n     */\n    pauseFocusOut() {\n        this.play();\n    }\n    /**\n     * Rolling to specified slide\n     * @param index: {number} index of slide, which must be shown\n     */\n    selectSlide(index) {\n        if (this.isPlaying) {\n            this.restartTimer();\n        }\n        if (!this.multilist) {\n            this.activeSlide = this.indicatorsByChunk ? index * this.itemsPerSlide : index;\n        }\n        else {\n            this.selectSlideRange(this.indicatorsByChunk ? index * this.itemsPerSlide : index);\n        }\n    }\n    /**\n     * Starts a auto changing of slides\n     */\n    play() {\n        if (!this.isPlaying) {\n            this.isPlaying = true;\n            this.restartTimer();\n        }\n    }\n    /**\n     * Stops a auto changing of slides\n     */\n    pause() {\n        if (!this.noPause) {\n            this.isPlaying = false;\n            this.resetTimer();\n        }\n    }\n    /**\n     * Finds and returns index of currently displayed slide\n     */\n    getCurrentSlideIndex() {\n        return this._slides.findIndex(this.getActive);\n    }\n    /**\n     * Defines, whether the specified index is last in collection\n     * @param index\n     */\n    isLast(index) {\n        return index + 1 >= this._slides.length;\n    }\n    /**\n     * Defines, whether the specified index is first in collection\n     * @param index\n     */\n    isFirst(index) {\n        return index === 0;\n    }\n    indicatorsSlides() {\n        return this.slides.filter((slide, index) => !this.indicatorsByChunk || index % this.itemsPerSlide === 0);\n    }\n    selectInitialSlides() {\n        const startIndex = this.startFromIndex <= this._slides.length\n            ? this.startFromIndex\n            : 0;\n        this.hideSlides();\n        if (this.singleSlideOffset) {\n            this._slidesWithIndexes = this.mapSlidesAndIndexes();\n            if (this._slides.length - startIndex < this.itemsPerSlide) {\n                const slidesToAppend = this._slidesWithIndexes.slice(0, startIndex);\n                this._slidesWithIndexes = [\n                    ...this._slidesWithIndexes,\n                    ...slidesToAppend\n                ]\n                    .slice(slidesToAppend.length)\n                    .slice(0, this.itemsPerSlide);\n            }\n            else {\n                this._slidesWithIndexes = this._slidesWithIndexes.slice(startIndex, startIndex + this.itemsPerSlide);\n            }\n            this._slidesWithIndexes.forEach((slide) => slide.item.active = true);\n            this.makeSlidesConsistent(this._slidesWithIndexes);\n        }\n        else {\n            this.selectRangeByNestedIndex(startIndex);\n        }\n        this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n    /**\n     * Defines next slide index, depending of direction\n     * @param direction: Direction(UNKNOWN|PREV|NEXT)\n     * @param force: {boolean} if TRUE - will ignore noWrap flag, else will\n     *   return undefined if next slide require wrapping\n     */\n    findNextSlideIndex(direction, force) {\n        let nextSlideIndex = 0;\n        if (!force &&\n            (this.isLast(this.activeSlide) &&\n                direction !== Direction.PREV &&\n                this.noWrap)) {\n            return;\n        }\n        switch (direction) {\n            case Direction.NEXT:\n                // if this is last slide, not force, looping is disabled\n                // and need to going forward - select current slide, as a next\n                if (typeof this._currentActiveSlide === 'undefined') {\n                    nextSlideIndex = 0;\n                    break;\n                }\n                if (!this.isLast(this._currentActiveSlide)) {\n                    nextSlideIndex = this._currentActiveSlide + 1;\n                    break;\n                }\n                nextSlideIndex = !force && this.noWrap ? this._currentActiveSlide : 0;\n                break;\n            case Direction.PREV:\n                // if this is first slide, not force, looping is disabled\n                // and need to going backward - select current slide, as a next\n                if (typeof this._currentActiveSlide === 'undefined') {\n                    nextSlideIndex = 0;\n                    break;\n                }\n                if (this._currentActiveSlide > 0) {\n                    nextSlideIndex = this._currentActiveSlide - 1;\n                    break;\n                }\n                if (!force && this.noWrap) {\n                    nextSlideIndex = this._currentActiveSlide;\n                    break;\n                }\n                nextSlideIndex = this._slides.length - 1;\n                break;\n            default:\n                throw new Error('Unknown direction');\n        }\n        return nextSlideIndex;\n    }\n    mapSlidesAndIndexes() {\n        return this.slides\n            .slice()\n            .map((slide, index) => {\n            return {\n                index,\n                item: slide\n            };\n        });\n    }\n    selectSlideRange(index) {\n        if (this.isIndexInRange(index)) {\n            return;\n        }\n        this.hideSlides();\n        if (!this.singleSlideOffset) {\n            this.selectRangeByNestedIndex(index);\n        }\n        else {\n            const startIndex = this.isIndexOnTheEdges(index)\n                ? index\n                : index - this.itemsPerSlide + 1;\n            const endIndex = this.isIndexOnTheEdges(index)\n                ? index + this.itemsPerSlide\n                : index + 1;\n            this._slidesWithIndexes = this.mapSlidesAndIndexes().slice(startIndex, endIndex);\n            this.makeSlidesConsistent(this._slidesWithIndexes);\n            this._slidesWithIndexes.forEach((slide) => slide.item.active = true);\n        }\n        this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n    selectRangeByNestedIndex(index) {\n        if (!this._chunkedSlides) {\n            return;\n        }\n        const selectedRange = this._chunkedSlides\n            .map((slidesList, i) => {\n            return {\n                index: i,\n                list: slidesList\n            };\n        })\n            .find((slidesList) => {\n            return slidesList.list.find(slide => slide.index === index) !== undefined;\n        });\n        if (!selectedRange) {\n            return;\n        }\n        this._currentVisibleSlidesIndex = selectedRange.index;\n        this._chunkedSlides[selectedRange.index].forEach((slide) => {\n            slide.item.active = true;\n        });\n    }\n    isIndexOnTheEdges(index) {\n        return (index + 1 - this.itemsPerSlide <= 0 ||\n            index + this.itemsPerSlide <= this._slides.length);\n    }\n    isIndexInRange(index) {\n        if (this.singleSlideOffset && this._slidesWithIndexes) {\n            const visibleIndexes = this._slidesWithIndexes.map((slide) => slide.index);\n            return visibleIndexes.indexOf(index) >= 0;\n        }\n        return (index <= this.getLastVisibleIndex() &&\n            index >= this.getFirstVisibleIndex());\n    }\n    hideSlides() {\n        this.slides.forEach((slide) => slide.active = false);\n    }\n    isVisibleSlideListLast() {\n        if (!this._chunkedSlides) {\n            return false;\n        }\n        return this._currentVisibleSlidesIndex === this._chunkedSlides.length - 1;\n    }\n    isVisibleSlideListFirst() {\n        return this._currentVisibleSlidesIndex === 0;\n    }\n    moveSliderByOneItem(direction) {\n        let firstVisibleIndex;\n        let lastVisibleIndex;\n        let indexToHide;\n        let indexToShow;\n        if (this.noWrap) {\n            firstVisibleIndex = this.getFirstVisibleIndex();\n            lastVisibleIndex = this.getLastVisibleIndex();\n            indexToHide = direction === Direction.NEXT\n                ? firstVisibleIndex\n                : lastVisibleIndex;\n            indexToShow = direction !== Direction.NEXT\n                ? firstVisibleIndex - 1\n                : !this.isLast(lastVisibleIndex)\n                    ? lastVisibleIndex + 1 : 0;\n            const slideToHide = this._slides.get(indexToHide);\n            if (slideToHide) {\n                slideToHide.active = false;\n            }\n            const slideToShow = this._slides.get(indexToShow);\n            if (slideToShow) {\n                slideToShow.active = true;\n            }\n            const slidesToReorder = this.mapSlidesAndIndexes().filter((slide) => slide.item.active);\n            this.makeSlidesConsistent(slidesToReorder);\n            if (this.singleSlideOffset) {\n                this._slidesWithIndexes = slidesToReorder;\n            }\n            this.slideRangeChange.emit(this.getVisibleIndexes());\n            return;\n        }\n        if (!this._slidesWithIndexes || !this._slidesWithIndexes[0]) {\n            return;\n        }\n        let index;\n        firstVisibleIndex = this._slidesWithIndexes[0].index;\n        lastVisibleIndex = this._slidesWithIndexes[this._slidesWithIndexes.length - 1].index;\n        if (direction === Direction.NEXT) {\n            this._slidesWithIndexes.shift();\n            index = this.isLast(lastVisibleIndex)\n                ? 0\n                : lastVisibleIndex + 1;\n            const item = this._slides.get(index);\n            if (item) {\n                this._slidesWithIndexes.push({ index, item });\n            }\n        }\n        else {\n            this._slidesWithIndexes.pop();\n            index = this.isFirst(firstVisibleIndex)\n                ? this._slides.length - 1\n                : firstVisibleIndex - 1;\n            const item = this._slides.get(index);\n            if (item) {\n                this._slidesWithIndexes = [{ index, item }, ...this._slidesWithIndexes];\n            }\n        }\n        this.hideSlides();\n        this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n        this.makeSlidesConsistent(this._slidesWithIndexes);\n        this.slideRangeChange.emit(this._slidesWithIndexes.map((slide) => slide.index));\n    }\n    moveMultilist(direction) {\n        if (this.singleSlideOffset) {\n            this.moveSliderByOneItem(direction);\n        }\n        else {\n            this.hideSlides();\n            if (this.noWrap) {\n                this._currentVisibleSlidesIndex = direction === Direction.NEXT\n                    ? this._currentVisibleSlidesIndex + 1\n                    : this._currentVisibleSlidesIndex - 1;\n            }\n            else if (direction === Direction.NEXT) {\n                this._currentVisibleSlidesIndex = this.isVisibleSlideListLast()\n                    ? 0\n                    : this._currentVisibleSlidesIndex + 1;\n            }\n            else {\n                if (this.isVisibleSlideListFirst()) {\n                    this._currentVisibleSlidesIndex = this._chunkedSlides\n                        ? this._chunkedSlides.length - 1\n                        : 0;\n                }\n                else {\n                    this._currentVisibleSlidesIndex = this._currentVisibleSlidesIndex - 1;\n                }\n            }\n            if (this._chunkedSlides) {\n                this._chunkedSlides[this._currentVisibleSlidesIndex].forEach((slide) => slide.item.active = true);\n            }\n            this.slideRangeChange.emit(this.getVisibleIndexes());\n        }\n    }\n    getVisibleIndexes() {\n        if (!this.singleSlideOffset && this._chunkedSlides) {\n            return this._chunkedSlides[this._currentVisibleSlidesIndex]\n                .map((slide) => slide.index);\n        }\n        if (this._slidesWithIndexes) {\n            return this._slidesWithIndexes.map((slide) => slide.index);\n        }\n    }\n    /**\n     * Sets a slide, which specified through index, as active\n     * @param index\n     */\n    _select(index) {\n        if (isNaN(index)) {\n            this.pause();\n            return;\n        }\n        if (!this.multilist && typeof this._currentActiveSlide !== 'undefined') {\n            const currentSlide = this._slides.get(this._currentActiveSlide);\n            if (typeof currentSlide !== 'undefined') {\n                currentSlide.active = false;\n            }\n        }\n        const nextSlide = this._slides.get(index);\n        if (typeof nextSlide !== 'undefined') {\n            this._currentActiveSlide = index;\n            nextSlide.active = true;\n            this.activeSlide = index;\n            this.activeSlideChange.emit(index);\n        }\n    }\n    /**\n     * Starts loop of auto changing of slides\n     */\n    restartTimer() {\n        this.resetTimer();\n        const interval = +this.interval;\n        if (!isNaN(interval) && interval > 0 && isPlatformBrowser(this.platformId)) {\n            this.currentInterval = this.ngZone.runOutsideAngular(() => {\n                return window.setInterval(() => {\n                    const nInterval = +this.interval;\n                    this.ngZone.run(() => {\n                        if (this.isPlaying &&\n                            !isNaN(this.interval) &&\n                            nInterval > 0 &&\n                            this.slides.length) {\n                            this.nextSlideFromInterval();\n                        }\n                        else {\n                            this.pause();\n                        }\n                    });\n                }, interval);\n            });\n        }\n    }\n    get multilist() {\n        return this.itemsPerSlide > 1;\n    }\n    /**\n     * Stops loop of auto changing of slides\n     */\n    resetTimer() {\n        if (this.currentInterval) {\n            clearInterval(this.currentInterval);\n            this.currentInterval = void 0;\n        }\n    }\n    checkDisabledClass(buttonType) {\n        if (buttonType === 'prev') {\n            return (this.activeSlide === 0 && this.noWrap && !this.multilist) || (this.isFirstSlideVisible && this.noWrap && this.multilist);\n        }\n        return (this.isLast(this.activeSlide) && this.noWrap && !this.multilist) || (this.isLastSlideVisible && this.noWrap && this.multilist);\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CarouselComponent, deps: [{ token: CarouselConfig }, { token: i0.NgZone }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"17.0.4\", type: CarouselComponent, selector: \"carousel\", inputs: { noWrap: \"noWrap\", noPause: \"noPause\", showIndicators: \"showIndicators\", pauseOnFocus: \"pauseOnFocus\", indicatorsByChunk: \"indicatorsByChunk\", itemsPerSlide: \"itemsPerSlide\", singleSlideOffset: \"singleSlideOffset\", isAnimated: \"isAnimated\", activeSlide: \"activeSlide\", startFromIndex: \"startFromIndex\", interval: \"interval\" }, outputs: { activeSlideChange: \"activeSlideChange\", slideRangeChange: \"slideRangeChange\" }, ngImport: i0, template: \"<div (mouseenter)=\\\"pause()\\\"\\n     (mouseleave)=\\\"onMouseLeave()\\\"\\n     (mouseup)=\\\"onMouseUp()\\\"\\n     (keydown)=\\\"keydownPress($event)\\\"\\n     (focusin)=\\\"pauseFocusIn()\\\"\\n     (focusout)=\\\"pauseFocusOut()\\\"\\n     [id]=\\\"'carousel' + currentId\\\"\\n     class=\\\"carousel slide\\\" tabindex=\\\"0\\\">\\n  <ng-container *ngIf=\\\"!_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <ol class=\\\"carousel-indicators\\\">\\n      <li *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n          [class.active]=\\\"slide.active === true\\\"\\n          (click)=\\\"selectSlide(i)\\\">\\n      </li>\\n    </ol>\\n  </ng-container>\\n  <ng-container *ngIf=\\\"_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <div class=\\\"carousel-indicators\\\">\\n      <button\\n        *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n        [class.active]=\\\"slide.active === true\\\"\\n        (click)=\\\"selectSlide(i)\\\"\\n        type=\\\"button\\\"\\n        [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n        [attr.data-bs-slide-to]=\\\"i\\\" aria-current=\\\"true\\\"\\n      >\\n      </button>\\n    </div>\\n  </ng-container>\\n  <div class=\\\"carousel-inner\\\" [ngStyle]=\\\"{'display': multilist ? 'flex' : 'block'}\\\">\\n    <ng-content></ng-content>\\n  </div>\\n  <a class=\\\"left carousel-control carousel-control-prev\\\"\\n     href=\\\"javascript:void(0);\\\"\\n     [class.disabled]=\\\"checkDisabledClass('prev')\\\"\\n     [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     (click)=\\\"previousSlide()\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-prev carousel-control-prev-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Previous</span>\\n  </a>\\n\\n  <a class=\\\"right carousel-control carousel-control-next\\\"\\n     href=\\\"javascript:void(0);\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     (click)=\\\"nextSlide()\\\"\\n     [class.disabled]=\\\"checkDisabledClass('next')\\\"\\n     [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-next carousel-control-next-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Next</span>\\n  </a>\\n</div>\\n\", dependencies: [{ kind: \"directive\", type: i2.NgForOf, selector: \"[ngFor][ngForOf]\", inputs: [\"ngForOf\", \"ngForTrackBy\", \"ngForTemplate\"] }, { kind: \"directive\", type: i2.NgIf, selector: \"[ngIf]\", inputs: [\"ngIf\", \"ngIfThen\", \"ngIfElse\"] }, { kind: \"directive\", type: i2.NgStyle, selector: \"[ngStyle]\", inputs: [\"ngStyle\"] }] }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CarouselComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'carousel', template: \"<div (mouseenter)=\\\"pause()\\\"\\n     (mouseleave)=\\\"onMouseLeave()\\\"\\n     (mouseup)=\\\"onMouseUp()\\\"\\n     (keydown)=\\\"keydownPress($event)\\\"\\n     (focusin)=\\\"pauseFocusIn()\\\"\\n     (focusout)=\\\"pauseFocusOut()\\\"\\n     [id]=\\\"'carousel' + currentId\\\"\\n     class=\\\"carousel slide\\\" tabindex=\\\"0\\\">\\n  <ng-container *ngIf=\\\"!_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <ol class=\\\"carousel-indicators\\\">\\n      <li *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n          [class.active]=\\\"slide.active === true\\\"\\n          (click)=\\\"selectSlide(i)\\\">\\n      </li>\\n    </ol>\\n  </ng-container>\\n  <ng-container *ngIf=\\\"_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <div class=\\\"carousel-indicators\\\">\\n      <button\\n        *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n        [class.active]=\\\"slide.active === true\\\"\\n        (click)=\\\"selectSlide(i)\\\"\\n        type=\\\"button\\\"\\n        [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n        [attr.data-bs-slide-to]=\\\"i\\\" aria-current=\\\"true\\\"\\n      >\\n      </button>\\n    </div>\\n  </ng-container>\\n  <div class=\\\"carousel-inner\\\" [ngStyle]=\\\"{'display': multilist ? 'flex' : 'block'}\\\">\\n    <ng-content></ng-content>\\n  </div>\\n  <a class=\\\"left carousel-control carousel-control-prev\\\"\\n     href=\\\"javascript:void(0);\\\"\\n     [class.disabled]=\\\"checkDisabledClass('prev')\\\"\\n     [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     (click)=\\\"previousSlide()\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-prev carousel-control-prev-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Previous</span>\\n  </a>\\n\\n  <a class=\\\"right carousel-control carousel-control-next\\\"\\n     href=\\\"javascript:void(0);\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     (click)=\\\"nextSlide()\\\"\\n     [class.disabled]=\\\"checkDisabledClass('next')\\\"\\n     [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-next carousel-control-next-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Next</span>\\n  </a>\\n</div>\\n\" }]\n        }], ctorParameters: () => [{ type: CarouselConfig }, { type: i0.NgZone }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }], propDecorators: { noWrap: [{\n                type: Input\n            }], noPause: [{\n                type: Input\n            }], showIndicators: [{\n                type: Input\n            }], pauseOnFocus: [{\n                type: Input\n            }], indicatorsByChunk: [{\n                type: Input\n            }], itemsPerSlide: [{\n                type: Input\n            }], singleSlideOffset: [{\n                type: Input\n            }], isAnimated: [{\n                type: Input\n            }], activeSlideChange: [{\n                type: Output\n            }], slideRangeChange: [{\n                type: Output\n            }], activeSlide: [{\n                type: Input\n            }], startFromIndex: [{\n                type: Input\n            }], interval: [{\n                type: Input\n            }] } });\n\nclass SlideComponent {\n    constructor(carousel) {\n        /** Is current slide active */\n        this.active = false;\n        this.itemWidth = '100%';\n        this.order = 0;\n        this.isAnimated = false;\n        /** Wraps element by appropriate CSS classes */\n        this.addClass = true;\n        this.multilist = false;\n        this.carousel = carousel;\n    }\n    /** Fires changes in container collection after adding a new slide instance */\n    ngOnInit() {\n        this.carousel.addSlide(this);\n        this.itemWidth = `${100 / this.carousel.itemsPerSlide}%`;\n        this.multilist = this.carousel?.itemsPerSlide > 1;\n    }\n    /** Fires changes in container collection after removing of this slide instance */\n    ngOnDestroy() {\n        this.carousel.removeSlide(this);\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: SlideComponent, deps: [{ token: CarouselComponent }], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"17.0.4\", type: SlideComponent, selector: \"slide\", inputs: { active: \"active\" }, host: { properties: { \"attr.aria-hidden\": \"!active\", \"class.multilist-margin\": \"multilist\", \"class.active\": \"this.active\", \"style.width\": \"this.itemWidth\", \"style.order\": \"this.order\", \"class.carousel-animation\": \"this.isAnimated\", \"class.item\": \"this.addClass\", \"class.carousel-item\": \"this.addClass\" } }, ngImport: i0, template: `\n    <div [class.active]=\"active\" class=\"item\">\n      <ng-content></ng-content>\n    </div>\n  `, isInline: true, styles: [\":host.carousel-animation{transition:opacity .6s ease,visibility .6s ease;float:left}:host.carousel-animation.active{opacity:1;visibility:visible}:host.carousel-animation:not(.active){display:block;position:absolute;opacity:0;visibility:hidden}:host.multilist-margin{margin-right:auto}:host.carousel-item{perspective:1000px}\\n\"] }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: SlideComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'slide', template: `\n    <div [class.active]=\"active\" class=\"item\">\n      <ng-content></ng-content>\n    </div>\n  `, host: {\n                        '[attr.aria-hidden]': '!active',\n                        '[class.multilist-margin]': 'multilist'\n                    }, styles: [\":host.carousel-animation{transition:opacity .6s ease,visibility .6s ease;float:left}:host.carousel-animation.active{opacity:1;visibility:visible}:host.carousel-animation:not(.active){display:block;position:absolute;opacity:0;visibility:hidden}:host.multilist-margin{margin-right:auto}:host.carousel-item{perspective:1000px}\\n\"] }]\n        }], ctorParameters: () => [{ type: CarouselComponent }], propDecorators: { active: [{\n                type: HostBinding,\n                args: ['class.active']\n            }, {\n                type: Input\n            }], itemWidth: [{\n                type: HostBinding,\n                args: ['style.width']\n            }], order: [{\n                type: HostBinding,\n                args: ['style.order']\n            }], isAnimated: [{\n                type: HostBinding,\n                args: ['class.carousel-animation']\n            }], addClass: [{\n                type: HostBinding,\n                args: ['class.item']\n            }, {\n                type: HostBinding,\n                args: ['class.carousel-item']\n            }] } });\n\nclass CarouselModule {\n    static forRoot() {\n        return { ngModule: CarouselModule, providers: [] };\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CarouselModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.0.4\", ngImport: i0, type: CarouselModule, declarations: [SlideComponent, CarouselComponent], imports: [CommonModule], exports: [SlideComponent, CarouselComponent] }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CarouselModule, imports: [CommonModule] }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CarouselModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [CommonModule],\n                    declarations: [SlideComponent, CarouselComponent],\n                    exports: [SlideComponent, CarouselComponent]\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CarouselComponent, CarouselConfig, CarouselModule, SlideComponent };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}